{
  "version": 3,
  "sources": ["../../@replit/codemirror-vim/dist/index.js"],
  "sourcesContent": ["import { EditorSelection, MapMode, Prec, RangeSetBuilder, StateEffect, StateField } from '@codemirror/state';\nimport { foldCode, matchBrackets, indentUnit, ensureSyntaxTree, StringStream } from '@codemirror/language';\nimport { runScopeHandlers, EditorView, Direction, ViewPlugin, Decoration, showPanel } from '@codemirror/view';\nimport { SearchQuery, setSearchQuery, RegExpCursor } from '@codemirror/search';\nimport { indentMore, indentLess, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorCharBackward, cursorCharLeft, insertNewlineAndIndent, indentSelection, undo, redo } from '@codemirror/commands';\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    // start and character position when no selection \n    // is the same in visual mode, and differs in 1 character in normal mode\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n\n    return {start: curStart, end: curEnd};\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><character>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    var vimToCmKeyMap = {};\n    'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKeys)).forEach(function(x) {\n      vimToCmKeyMap[(specialKeys[x] || '').toLowerCase()]\n         = vimToCmKeyMap[x.toLowerCase()] = x;\n    });\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          insertModeReturn: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      leaveVimMode: leaveVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx, true);\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          vim.inputState.keyBuffer.push(key);\n          var keys = vim.inputState.keyBuffer.join(\"\");\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          var changeQueue = vim.inputState.changeQueue;\n\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = keysAreChars && window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer.length) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            if (keysAreChars) {\n              var selections = cm.listSelections();\n              if (!changeQueue || changeQueue.removed.length != selections.length)\n                changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n              changeQueue.inserted += key;\n              for (var i = 0; i < selections.length; i++) {\n                var from = cursorMin(selections[i].anchor, selections[i].head);\n                var to = cursorMax(selections[i].anchor, selections[i].head);\n                var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n                changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n              }\n            }\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (match.command && changeQueue) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange(changeQueue.removed[i] || \"\", \n                offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          if (!match.command) clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          vim.inputState.keyBuffer.push(key);\n          var keys = vim.inputState.keyBuffer.join(\"\");\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer.length = 0;\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(cm, command.toKeys, command);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    var keyToKeyStack = [];\n    var noremap = false;\n    function doKeyToKey(cm, keys, fromKey) {\n      // prevent infinite recursion.\n      if (fromKey) {\n        if (keyToKeyStack.indexOf(fromKey) != -1) return;\n        keyToKeyStack.push(fromKey);\n        noremap = fromKey.noremap;\n      }\n\n      try {\n        var vim = maybeInitVimState(cm);\n        var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n\n        var match;\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        while ((match = keyRe.exec(keys))) {\n          var key = match[0];\n          var wasInsert = vim.insertMode;\n          var result = vimApi.handleKey(cm, key, 'mapping');\n\n          if (!result && wasInsert && vim.insertMode) {\n            if (key[0] == \"<\") {\n              var lowerKey = key.toLowerCase().slice(1, -1);\n              var parts = lowerKey.split('-');\n              var lowerKey = parts.pop();\n              if (lowerKey == 'lt') key = '<';\n              else if (lowerKey == 'space') key = ' ';\n              else if (lowerKey == 'cr') key = '\\n';\n              else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n                // todo support codemirror  keys in insertmode vimToCmKeyMap\n                key = vimToCmKeyMap[lowerKey];\n                sendCmKey(cm, key);\n                continue;\n              } else {\n                key = key[0];\n                keyRe.lastIndex = match.index + 1;\n              }\n            }\n            cm.replaceSelection(key);\n          }\n        }\n      } finally {\n        noremap = false;\n        keyToKeyStack.length = 0;\n      }\n    }\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n      this.changeQueue = null; // For restoring text used by insert mode keybindings\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    function ChangeQueue() {\n      this.removed = [];\n      this.inserted = \"\";\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+') {\n          navigator.clipboard.writeText(text);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                false /** innerWord */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  false /** innerWord */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          if (cm.state.vim) clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, oldHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n            cmSel = makeCmSelection(cm, {\n              anchor: newPositions.start,\n              head: newPositions.end\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n            cmSel = makeCmSelection(cm, {\n              anchor: newPositions.start,\n              head: newPositions.end\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter, head);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter, head) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp, move;\n        if (mirroredPairs[character]) {\n          move = true;\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n          if (!tmp) {\n            var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n            if (sc.find()) {\n              tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n            }\n          }\n        } else if (selfPaired[character]) {\n          move = true;\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, !inclusive /** innerWord */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, !inclusive /** innerWord */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        }\n\n        if (!tmp) {\n          // No valid text object, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end, move);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n          head = newPosition.end;\n        } else if (insertAt == 'firstNonBlank') {\n          var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n          head = newPosition.end;\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          if (vim.insertEnd) vim.insertEnd.clear();\n          vim.insertEnd = cm.setBookmark(head, {insertLeft: true});\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n          vim.sel = {\n            anchor: newPosition.start,\n            head: newPosition.end\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var text = '';\n          var nextStartCh = 0;\n          if (!actionArgs.keepSpaces) {\n            var nextLine = cm.getLine(curStart.line + 1);\n            nextStartCh = nextLine.search(/\\S/);\n            if (nextStartCh == -1) {\n              nextStartCh = nextLine.length;\n            } else {\n              text = \" \";\n            }\n          }\n          cm.replaceRange(text, \n            new Pos(curStart.line, finalCh),\n            new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        if (actionArgs.registerName === '+') {\n          navigator.clipboard.readText().then((value) => {\n            this.continuePaste(cm, actionArgs, vim, value, register);\n          });\n        } else {\n          var text = register.toString();\n          this.continuePaste(cm, actionArgs, vim, text, register);\n        }\n      },\n      continuePaste: function(cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n            text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise) {\n              var line = actionArgs.after ? cur.line + 1 : cur.line;\n              curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n            } else {\n              curPosFinal = copyCursor(cur);\n              if (!/\\n/.test(text)) {\n                curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n              }\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      insertRegister: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        var text = register && register.toString();\n        if (text) {\n          cm.replaceSelection(text);\n        }\n      },\n      oneNormalCommand: function(cm, actionArgs, vim) {\n        exitInsertMode(cm, true);\n        vim.insertModeReturn = true;\n        CodeMirror.on(cm, 'vim-command-done', function handler() {\n          if (vim.visualMode) return;\n          if (vim.insertModeReturn) {\n            vim.insertModeReturn = false;\n            if (!vim.insertMode) {\n              actions.enterInsertMode(cm, {}, vim);\n            }\n          }\n          CodeMirror.off(cm, 'vim-command-done', handler);\n        });\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          // replace all surrogate characters with selected character\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * and is not inside surrogate pair\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, oldCur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var text = cm.getLine(line);\n      var maxCh = text.length - 1 + Number(!!includeLineBreak);\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      // prevent cursor from entering surrogate pair\n      var charCode = text.charCodeAt(ch);\n      if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n          direction = -1;\n        }\n        ch +=direction;\n        if (ch > maxCh) ch -=2;\n      }\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var operatorPending = inputState.operator;\n      var match, partial = [], full = [];\n      // if currently expanded key comes from a noremap, searcg only in default keys\n      var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n      for (var i = startIndex; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            (command.context == \"operatorPending\" ? !operatorPending \n              : command.context && command.context != context) ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end, move) {\n      var sel = cm.state.vim.sel;\n      var head = move ? start: sel.head;\n      var anchor = move ? start: sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, innerWord, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      if (innerWord && /\\s/.test(line.charAt(idx))) {\n        test = function(ch) { return /\\s/.test(ch); };\n      } else {\n        while (!test(line.charAt(idx))) {\n          idx++;\n          if (idx >= line.length) { return null; }\n        }\n\n        if (bigWord) {\n          test = bigWordCharTest[0];\n        } else {\n          test = wordCharTest[0];\n          if (!test(line.charAt(idx))) {\n            test = wordCharTest[1];\n          }\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character, head) {\n      var cur = head || cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    /**\n     * Based on {@link findSentence}. The internal functions have the same names,\n     * but their behaviour is different. findSentence() crosses line breaks and \n     * is used for jumping to sentence beginnings before or after the current cursor position, \n     * whereas getSentence() is for getting the beginning or end of the sentence \n     * at the current cursor position, either including (a) or excluding (i) whitespace.\n     */\n    function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the pos member to represent the\n        next valid position or sets the line to null if there are\n        no more valid positions.\n       */\n      function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n        else {\n          curr.pos += curr.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the sentence end\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          lastSentencePos = curr.pos;\n          if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: curr.pos + 1 };\n            } \n            else {\n              nextChar(curr);\n              while (curr.line !== null ) {\n                if (isWhiteSpaceString(curr.line[curr.pos])) {\n                  lastSentencePos = curr.pos;\n                  nextChar(curr);\n                } \n                else {\n                  break;\n                }\n              }\n              return { ln: curr.ln, pos: lastSentencePos + 1 };\n            }\n          }\n          nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the sentence start\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            lastSentencePos = curr.pos;\n          }\n\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: lastSentencePos };\n            } \n            else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1 };\n              } \n              else {\n                return { ln: curr.ln, pos: lastSentencePos };\n              }\n            }\n          }\n\n          nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n          return { ln: curr.ln, pos: curr.pos };\n        } \n        else {\n          return { ln: curr.ln, pos: lastSentencePos };\n        }\n\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n       /*\n         Takes an index object\n         {\n           line: the line string,\n           ln: line number,\n           pos: index in line,\n           dir: direction of traversal (-1 or 1)\n         }\n         and modifies the line, ln, and pos members to represent the\n         next valid position or sets them to null if there are\n         no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) return null;\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n        var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n        var isStringStart = stringAfter && !stringBefore;\n        if (!isStringStart) {\n          end = cur.ch; // assign end to the current cursor\n          --cur.ch; // make sure to look backwards\n        }\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom('div', {$display: 'flex'},\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false', $width: '100%'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      if (cm.getLastEditEnd) {\n        return cm.getLastEditEnd();\n      }\n      // for old cm\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        if (result.line == undefined) {\n          if (cm.state.vim.visualMode) {\n            result.selectionLine = getMarkPos(cm, cm.state.vim, '<')?.line;\n            result.selectionLineEnd = getMarkPos(cm, cm.state.vim, '>')?.line;\n          } else {\n            result.selectionLine = cm.getCursor().line;\n          }\n        } else {\n          result.selectionLine = result.line;\n          result.selectionLineEnd = result.lineEnd;\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx, noremap) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs,\n              noremap: noremap\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx, defaultOnly) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      omap: function(cm, params) { this.map(cm, params, 'operatorPending'); },\n      noremap: function(cm, params) { this.map(cm, params, undefined, true); },\n      inoremap: function(cm, params) { this.map(cm, params, 'insert', true); },\n      nnoremap: function(cm, params) { this.map(cm, params, 'normal', true); },\n      vnoremap: function(cm, params) { this.map(cm, params, 'visual', true); },\n      onoremap: function(cm, params) { this.map(cm, params, 'operatorPending', true); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      mapclear: function(cm, params) { vimApi.mapclear(); },\n      imapclear: function(cm, params) { vimApi.mapclear('insert'); },\n      nmapclear: function(cm, params) { vimApi.mapclear('normal'); },\n      vmapclear: function(cm, params) { vimApi.mapclear('visual'); },\n      omapclear: function(cm, params) { vimApi.mapclear('operatorPending'); },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      normal: function(cm, params) {\n        var argString = params.argString && params.argString.trimStart();\n        if (!argString) {\n          showConfirm(cm, 'Argument is required.');\n          return;\n        }\n        var line = params.line;\n        if (typeof line == 'number') {\n          var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n          for (var i = line; i <= lineEnd; i++) {\n            cm.setCursor(i, 0);\n            doKeyToKey(cm, params.argString.trimStart());\n            if (cm.state.vim.insertMode) {\n              exitInsertMode(cm, true);\n            }\n          }\n        } else {\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        if (argString[0] === '!' && params.commandName[0] === 'g') {\n          inverted = true;\n          argString = argString.slice(1);\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLine(i);\n          var matched = query.test(line);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var lineHandle = matchedLines[index++];\n            var lineNum = cm.getLineNumber(lineHandle);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          } else if (cm.releaseLineHandles) {\n            cm.releaseLineHandles();\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delete: function(cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        operators.delete(cm, {linewise: true}, [\n          { anchor: new Pos(line, 0),\n            head: new Pos(lineEnd + 1, 0) }\n        ]);\n      },\n      join: function(cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        cm.setCursor(new Pos(line, 0));\n        actions.joinLines(cm, {repeat: lineEnd - line}, cm.state.vim);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm, keepCursor) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = null;\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      if (!keepCursor) {\n        cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      }\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        var vim = cm.state.vim;\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                if (text.length > 1) {\n                  var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                  var cursor = cm.getCursor();\n                  if (insertEnd && insertEnd.line == cursor.line) {\n                    var offset = insertEnd.ch - cursor.ch;\n                    if (offset > 0 && offset < text.length) {\n                      lastChange.changes.push([text, offset]);\n                      text = '';\n                    }\n                  }\n                }\n                if (text) lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n          if (vim.insertEnd) vim.insertEnd.clear();\n          vim.insertEnd = cm.setBookmark(cm.getCursor(), {insertLeft: true});\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function sendCmKey(cm, key) {\n      CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      });\n    }\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            sendCmKey(cm, change.keyName);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n            cm.replaceRange(change[0], start, change[1] ? start: end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        if (key == \"insertEnd\") return;\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n        var changeQueueList = vim.inputState.changeQueueList || [];\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          var index = 0;\n          cm.forEachSelection(function() {\n            cm.state.vim.inputState.changeQueue = changeQueueList[index];\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n              cm.state.vim = cloneVimState(old);\n            }\n            index++;\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n          vim.inputState.changeQueueList = changeQueueList;\n          vim.inputState.changeQueue = null;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction indexFromPos(doc, pos) {\n    var ch = pos.ch;\n    var lineNumber = pos.line + 1;\n    if (lineNumber < 1) {\n        lineNumber = 1;\n        ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n        lineNumber = doc.lines;\n        ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n    let line = doc.lineAt(offset);\n    return { line: line.number - 1, ch: offset - line.from };\n}\nclass Pos {\n    constructor(line, ch) {\n        this.line = line;\n        this.ch = ch;\n    }\n}\nfunction on(emitter, type, f) {\n    if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers || (emitter._handlers = {});\n        map[type] = (map[type] || []).concat(f);\n    }\n}\nfunction off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers, arr = map && map[type];\n        if (arr) {\n            var index = arr.indexOf(f);\n            if (index > -1) {\n                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n            }\n        }\n    }\n}\nfunction signal(emitter, type, ...args) {\n    var _a;\n    var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nfunction signalTo(handlers, ...args) {\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nvar specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n};\nvar ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n    CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) {\n    wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n    var view = cm.cm6;\n    var type = \"input.type.compose\";\n    if (cm.curOp) {\n        if (!cm.curOp.lastChange)\n            type = \"input.type.compose.start\";\n    }\n    if (transaction.annotations) {\n        try {\n            transaction.annotations.some(function (note) {\n                if (note.value == \"input\")\n                    note.value = type;\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    else {\n        transaction.userEvent = type;\n    }\n    return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n    var _a;\n    if (cm.curOp) {\n        cm.curOp.$changeStart = undefined;\n    }\n    (revert ? undo : redo)(cm.cm6);\n    let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n    // vim mode expects the changed text to be either selected or cursor placed at the start\n    if (changeStartIndex != null) {\n        cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });\n    }\n}\nvar keys = {};\n/*@__PURE__*/\"Left|Right|Up|Down|Backspace|Delete\".split(\"|\").forEach(key => {\n    keys[key] = (cm) => runScopeHandlers(cm.cm6, { key: key }, \"editor\");\n});\nclass CodeMirror {\n    constructor(cm6) {\n        this.state = {};\n        this.marks = Object.create(null);\n        this.$mid = 0; // marker id counter\n        this.options = {};\n        this._handlers = {};\n        this.$lastChangeEndOffset = 0;\n        this.virtualSelection = null;\n        this.cm6 = cm6;\n        this.onChange = this.onChange.bind(this);\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    // --------------------------\n    openDialog(template, callback, options) {\n        return openDialog(this, template, callback, options);\n    }\n    ;\n    openNotification(template, options) {\n        return openNotification(this, template, options);\n    }\n    ;\n    ;\n    on(type, f) { on(this, type, f); }\n    off(type, f) { off(this, type, f); }\n    signal(type, e, handlers) { signal(this, type, e, handlers); }\n    indexFromPos(pos) {\n        return indexFromPos(this.cm6.state.doc, pos);\n    }\n    ;\n    posFromIndex(offset) {\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    foldCode(pos) {\n        let view = this.cm6;\n        let ranges = view.state.selection.ranges;\n        let doc = this.cm6.state.doc;\n        let index = indexFromPos(doc, pos);\n        let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;\n        view.state.selection.ranges = tmpRanges;\n        foldCode(view);\n        view.state.selection.ranges = ranges;\n    }\n    firstLine() { return 0; }\n    ;\n    lastLine() { return this.cm6.state.doc.lines - 1; }\n    ;\n    lineCount() { return this.cm6.state.doc.lines; }\n    ;\n    setCursor(line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var offset = indexFromPos(this.cm6.state.doc, { line, ch });\n        this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });\n        if (this.curOp && !this.curOp.isVimOp)\n            this.onBeforeEndOperation();\n    }\n    ;\n    getCursor(p) {\n        var sel = this.cm6.state.selection.main;\n        var offset = p == \"head\" || !p\n            ? sel.head\n            : p == \"anchor\"\n                ? sel.anchor\n                : p == \"start\"\n                    ? sel.from\n                    : p == \"end\"\n                        ? sel.to\n                        : null;\n        if (offset == null)\n            throw new Error(\"Invalid cursor type\");\n        return this.posFromIndex(offset);\n    }\n    ;\n    listSelections() {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.selection.ranges.map(r => {\n            return {\n                anchor: posFromIndex(doc, r.anchor),\n                head: posFromIndex(doc, r.head),\n            };\n        });\n    }\n    ;\n    setSelections(p, primIndex) {\n        var doc = this.cm6.state.doc;\n        var ranges = p.map(x => {\n            return EditorSelection.range(indexFromPos(doc, x.anchor), indexFromPos(doc, x.head));\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, primIndex)\n        });\n    }\n    ;\n    setSelection(anchor, head, options) {\n        var doc = this.cm6.state.doc;\n        var ranges = [EditorSelection.range(indexFromPos(doc, anchor), indexFromPos(doc, head))];\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, 0)\n        });\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    }\n    ;\n    getLine(row) {\n        var doc = this.cm6.state.doc;\n        if (row < 0 || row >= doc.lines)\n            return \"\";\n        return this.cm6.state.doc.line(row + 1).text;\n    }\n    ;\n    getLineHandle(row) {\n        if (!this.$lineHandleChanges)\n            this.$lineHandleChanges = [];\n        return { row: row, index: this.indexFromPos(new Pos(row, 0)) };\n    }\n    getLineNumber(handle) {\n        var updates = this.$lineHandleChanges;\n        if (!updates)\n            return null;\n        var offset = handle.index;\n        for (var i = 0; i < updates.length; i++) {\n            offset = updates[i].changes.mapPos(offset, 1, MapMode.TrackAfter);\n            if (offset == null)\n                return null;\n        }\n        var pos = this.posFromIndex(offset);\n        return pos.ch == 0 ? pos.line : null;\n    }\n    releaseLineHandles() {\n        this.$lineHandleChanges = undefined;\n    }\n    getRange(s, e) {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n    }\n    ;\n    replaceRange(text, s, e) {\n        if (!e)\n            e = s;\n        var doc = this.cm6.state.doc;\n        var from = indexFromPos(doc, s);\n        var to = indexFromPos(doc, e);\n        dispatchChange(this, { changes: { from, to, insert: text } });\n    }\n    ;\n    replaceSelection(text) {\n        dispatchChange(this, this.cm6.state.replaceSelection(text));\n    }\n    ;\n    replaceSelections(replacements) {\n        var ranges = this.cm6.state.selection.ranges;\n        var changes = ranges.map((r, i) => {\n            return { from: r.from, to: r.to, insert: replacements[i] || \"\" };\n        });\n        dispatchChange(this, { changes });\n    }\n    ;\n    getSelection() {\n        return this.getSelections().join(\"\\n\");\n    }\n    ;\n    getSelections() {\n        var cm = this.cm6;\n        return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n    }\n    ;\n    somethingSelected() {\n        return this.cm6.state.selection.ranges.some(r => !r.empty);\n    }\n    ;\n    getInputField() {\n        return this.cm6.contentDOM;\n    }\n    ;\n    clipPos(p) {\n        var doc = this.cm6.state.doc;\n        var ch = p.ch;\n        var lineNumber = p.line + 1;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            ch = 0;\n        }\n        if (lineNumber > doc.lines) {\n            lineNumber = doc.lines;\n            ch = Number.MAX_VALUE;\n        }\n        var line = doc.line(lineNumber);\n        ch = Math.min(Math.max(0, ch), line.to - line.from);\n        return new Pos(lineNumber - 1, ch);\n    }\n    ;\n    getValue() {\n        return this.cm6.state.doc.toString();\n    }\n    ;\n    setValue(text) {\n        var cm = this.cm6;\n        return cm.dispatch({\n            changes: { from: 0, to: cm.state.doc.length, insert: text },\n            selection: EditorSelection.range(0, 0)\n        });\n    }\n    ;\n    focus() {\n        return this.cm6.focus();\n    }\n    ;\n    blur() {\n        return this.cm6.contentDOM.blur();\n    }\n    ;\n    defaultTextHeight() {\n        return this.cm6.defaultLineHeight;\n    }\n    ;\n    findMatchingBracket(pos) {\n        var state = this.cm6.state;\n        var offset = indexFromPos(state.doc, pos);\n        var m = matchBrackets(state, offset + 1, -1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        m = matchBrackets(state, offset, 1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        return { to: undefined };\n    }\n    ;\n    scanForBracket(pos, dir, style, config) {\n        return scanForBracket(this, pos, dir, style, config);\n    }\n    ;\n    indentLine(line, more) {\n        // todo how to indent only one line instead of selection\n        if (more)\n            this.indentMore();\n        else\n            this.indentLess();\n    }\n    ;\n    indentMore() {\n        indentMore(this.cm6);\n    }\n    ;\n    indentLess() {\n        indentLess(this.cm6);\n    }\n    ;\n    execCommand(name) {\n        if (name == \"indentAuto\")\n            CodeMirror.commands.indentAuto(this);\n        else if (name == \"goLineLeft\")\n            cursorLineBoundaryBackward(this.cm6);\n        else if (name == \"goLineRight\") {\n            cursorLineBoundaryForward(this.cm6);\n            cursorCharBackward(this.cm6);\n        }\n        else\n            console.log(name + \" is not implemented\");\n    }\n    ;\n    setBookmark(cursor, options) {\n        var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n        var offset = this.indexFromPos(cursor);\n        var bm = new Marker(this, offset, assoc);\n        return bm;\n    }\n    ;\n    addOverlay({ query }) {\n        let cm6Query = new SearchQuery({\n            regexp: true,\n            search: query.source,\n            caseSensitive: !/i/.test(query.flags),\n        });\n        if (cm6Query.valid) {\n            cm6Query.forVim = true;\n            this.cm6Query = cm6Query;\n            let effect = setSearchQuery.of(cm6Query);\n            this.cm6.dispatch({ effects: effect });\n            return cm6Query;\n        }\n    }\n    ;\n    removeOverlay(overlay) {\n        if (!this.cm6Query)\n            return;\n        this.cm6Query.forVim = false;\n        let effect = setSearchQuery.of(this.cm6Query);\n        this.cm6.dispatch({ effects: effect });\n    }\n    ;\n    getSearchCursor(query, pos) {\n        var cm = this;\n        var last = null;\n        var lastCM5Result = null;\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n        var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n            if (!b)\n                return \"\\\\\" + a;\n            return b;\n        });\n        function rCursor(doc, from = 0, to = doc.length) {\n            return new RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);\n        }\n        function nextMatch(from) {\n            var doc = cm.cm6.state.doc;\n            if (from > doc.length)\n                return null;\n            let res = rCursor(doc, from).next();\n            return res.done ? null : res.value;\n        }\n        var ChunkSize = 10000;\n        function prevMatchInRange(from, to) {\n            var doc = cm.cm6.state.doc;\n            for (let size = 1;; size++) {\n                let start = Math.max(from, to - size * ChunkSize);\n                let cursor = rCursor(doc, start, to), range = null;\n                while (!cursor.next().done)\n                    range = cursor.value;\n                if (range && (start == from || range.from > start + 10))\n                    return range;\n                if (start == from)\n                    return null;\n            }\n        }\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                var doc = cm.cm6.state.doc;\n                if (back) {\n                    let endAt = last ? (last.from == last.to ? last.to - 1 : last.from) : firstOffset;\n                    last = prevMatchInRange(0, endAt);\n                }\n                else {\n                    let startFrom = last ? (last.from == last.to ? last.to + 1 : last.to) : firstOffset;\n                    last = nextMatch(startFrom);\n                }\n                lastCM5Result = last && {\n                    from: posFromIndex(doc, last.from),\n                    to: posFromIndex(doc, last.to),\n                    match: last.match,\n                };\n                return last && last.match;\n            },\n            from: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from; },\n            to: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to; },\n            replace: function (text) {\n                if (last) {\n                    dispatchChange(cm, {\n                        changes: { from: last.from, to: last.to, insert: text }\n                    });\n                    last.to = last.from + text.length;\n                    if (lastCM5Result) {\n                        lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n                    }\n                }\n            }\n        };\n    }\n    ;\n    findPosV(start, amount, unit, goalColumn) {\n        let { cm6 } = this;\n        const doc = cm6.state.doc;\n        let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n        const startOffset = indexFromPos(doc, start);\n        let range = EditorSelection.range(startOffset, startOffset, goalColumn);\n        let count = Math.round(Math.abs(amount));\n        for (let i = 0; i < count; i++) {\n            if (unit == 'page') {\n                range = cm6.moveVertically(range, amount > 0, pixels);\n            }\n            else if (unit == 'line') {\n                range = cm6.moveVertically(range, amount > 0);\n            }\n        }\n        let pos = posFromIndex(doc, range.head);\n        // set hitside to true if there was no place to move and cursor was clipped to the edge\n        // of document. Needed for gj/gk\n        if ((amount < 0 &&\n            range.head == 0 && goalColumn != 0 &&\n            start.line == 0 && start.ch != 0) || (amount > 0 &&\n            range.head == doc.length && pos.ch != goalColumn\n            && start.line == pos.line)) {\n            pos.hitSide = true;\n        }\n        return pos;\n    }\n    ;\n    charCoords(pos, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = indexFromPos(this.cm6.state.doc, pos);\n        var coords = this.cm6.coordsAtPos(offset);\n        var d = -rect.top;\n        return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d };\n    }\n    ;\n    coordsChar(coords, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    getScrollInfo() {\n        var scroller = this.cm6.scrollDOM;\n        return {\n            left: scroller.scrollLeft, top: scroller.scrollTop,\n            height: scroller.scrollHeight,\n            width: scroller.scrollWidth,\n            clientHeight: scroller.clientHeight, clientWidth: scroller.clientWidth\n        };\n    }\n    ;\n    scrollTo(x, y) {\n        if (x != null)\n            this.cm6.scrollDOM.scrollLeft = x;\n        if (y != null)\n            this.cm6.scrollDOM.scrollTop = y;\n    }\n    ;\n    scrollIntoView(pos, margin) {\n        if (pos) {\n            var offset = this.indexFromPos(pos);\n            this.cm6.dispatch({\n                effects: EditorView.scrollIntoView(offset)\n            });\n        }\n        else {\n            this.cm6.dispatch({ scrollIntoView: true, userEvent: \"scroll\" });\n        }\n    }\n    ;\n    getWrapperElement() {\n        return this.cm6.dom;\n    }\n    ;\n    // for tests\n    getMode() {\n        return { name: this.getOption(\"mode\") };\n    }\n    ;\n    setSize(w, h) {\n        this.cm6.dom.style.width = w + 4 + \"px\";\n        this.cm6.dom.style.height = h + \"px\";\n        this.refresh();\n    }\n    refresh() {\n        this.cm6.measure();\n    }\n    // event listeners\n    destroy() {\n        this.removeOverlay();\n    }\n    ;\n    getLastEditEnd() {\n        return this.posFromIndex(this.$lastChangeEndOffset);\n    }\n    ;\n    onChange(update) {\n        if (this.$lineHandleChanges) {\n            this.$lineHandleChanges.push(update);\n        }\n        for (let i in this.marks) {\n            let m = this.marks[i];\n            m.update(update.changes);\n        }\n        if (this.virtualSelection) {\n            this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n        }\n        var curOp = this.curOp = this.curOp || {};\n        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n            if (curOp.$changeStart == null || curOp.$changeStart > fromB)\n                curOp.$changeStart = fromB;\n            this.$lastChangeEndOffset = toB;\n            var change = { text: text.toJSON() };\n            if (!curOp.lastChange) {\n                curOp.lastChange = curOp.change = change;\n            }\n            else {\n                curOp.lastChange.next = curOp.lastChange = change;\n            }\n        }, true);\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n    }\n    ;\n    onSelectionChange() {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n    }\n    ;\n    operation(fn) {\n        if (!this.curOp)\n            this.curOp = { $d: 0 };\n        this.curOp.$d++;\n        try {\n            var result = fn();\n        }\n        finally {\n            if (this.curOp) {\n                this.curOp.$d--;\n                if (!this.curOp.$d)\n                    this.onBeforeEndOperation();\n            }\n        }\n        return result;\n    }\n    ;\n    onBeforeEndOperation() {\n        var op = this.curOp;\n        var scrollIntoView = false;\n        if (op) {\n            if (op.change) {\n                signalTo(op.changeHandlers, this, op.change);\n            }\n            if (op && op.cursorActivity) {\n                signalTo(op.cursorActivityHandlers, this, null);\n                if (op.isVimOp)\n                    scrollIntoView = true;\n            }\n            this.curOp = null;\n        }\n        if (scrollIntoView)\n            this.scrollIntoView();\n    }\n    ;\n    moveH(increment, unit) {\n        if (unit == 'char') {\n            // todo\n            var cur = this.getCursor();\n            this.setCursor(cur.line, cur.ch + increment);\n        }\n    }\n    ;\n    setOption(name, val) {\n        switch (name) {\n            case \"keyMap\":\n                this.state.keyMap = val;\n                break;\n        }\n    }\n    ;\n    getOption(name) {\n        switch (name) {\n            case \"firstLineNumber\": return 1;\n            case \"tabSize\": return this.cm6.state.tabSize || 4;\n            case \"readonly\": return this.cm6.state.readOnly;\n            case \"indentWithTabs\": return this.cm6.state.facet(indentUnit) == \"\\t\"; // TODO\n            case \"indentUnit\": return this.cm6.state.facet(indentUnit).length || 2;\n            // for tests\n            case \"keyMap\": return this.state.keyMap || \"vim\";\n        }\n    }\n    ;\n    toggleOverwrite(on) {\n        this.state.overwrite = on;\n    }\n    ;\n    getTokenTypeAt(pos) {\n        var _a;\n        // only comment|string are needed\n        var offset = this.indexFromPos(pos);\n        var tree = ensureSyntaxTree(this.cm6.state, offset);\n        var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n        var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n        if (/comment/i.test(type))\n            return \"comment\";\n        if (/string/i.test(type))\n            return \"string\";\n        return \"\";\n    }\n    ;\n    overWriteSelection(text) {\n        var doc = this.cm6.state.doc;\n        var sel = this.cm6.state.selection;\n        var ranges = sel.ranges.map(x => {\n            if (x.empty) {\n                var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n                if (ch && !/\\n/.test(ch))\n                    return EditorSelection.range(x.from, x.to + 1);\n            }\n            return x;\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, sel.mainIndex)\n        });\n        this.replaceSelection(text);\n    }\n    /*** multiselect ****/\n    isInMultiSelectMode() {\n        return this.cm6.state.selection.ranges.length > 1;\n    }\n    virtualSelectionMode() {\n        return !!this.virtualSelection;\n    }\n    forEachSelection(command) {\n        var selection = this.cm6.state.selection;\n        this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);\n        for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n            var range = this.virtualSelection.ranges[i];\n            if (!range)\n                continue;\n            this.cm6.dispatch({ selection: EditorSelection.create([range]) });\n            command();\n            this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n        }\n        this.cm6.dispatch({ selection: this.virtualSelection });\n        this.virtualSelection = null;\n    }\n}\nCodeMirror.isMac = typeof navigator != \"undefined\" && /*@__PURE__*//Mac/.test(navigator.platform);\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = StringStream;\nCodeMirror.commands = {\n    cursorCharLeft: function (cm) { cursorCharLeft(cm.cm6); },\n    redo: function (cm) { runHistoryCommand(cm, false); },\n    undo: function (cm) { runHistoryCommand(cm, true); },\n    newlineAndIndent: function (cm) {\n        insertNewlineAndIndent({\n            state: cm.cm6.state,\n            dispatch: (tr) => {\n                return dispatchChange(cm, tr);\n            }\n        });\n    },\n    indentAuto: function (cm) {\n        indentSelection(cm.cm6);\n    }\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.isWordChar = function (ch) {\n    return wordChar.test(ch);\n};\nCodeMirror.keys = keys;\nCodeMirror.keyMap = {};\nCodeMirror.addClass = function () { };\nCodeMirror.rmClass = function () { };\nCodeMirror.e_preventDefault = function (e) {\n    e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n    var _a, _b;\n    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.keyName = function (e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key == \"Escape\")\n        key = \"Esc\";\n    if (key == \" \")\n        key = \"Space\";\n    if (key.length > 1) {\n        key = key.replace(/Numpad|Arrow/, \"\");\n    }\n    if (key.length == 1)\n        key = key.toUpperCase();\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'Ctrl-';\n    }\n    if (e.altKey) {\n        name += 'Alt-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'Shift-';\n    }\n    name += key;\n    return name;\n};\nCodeMirror.vimKey = function vimKey(e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if (e.metaKey) {\n        name += 'M-';\n    }\n    // on mac many characters are entered as option- combos\n    // (e.g. on swiss keyboard { is option-8)\n    // so we ignore lonely A- modifier for keypress event on mac\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n        name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    var result = CodeMirror.keys[key];\n    if (result)\n        handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n    var dialog = document.createElement(\"div\");\n    dialog.appendChild(template);\n    return dialog;\n}\nfunction closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n    closeNotification(cm, close);\n    var dialog = dialogDiv(cm, template, options && options.bottom);\n    var closed = false;\n    var doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n    function close() {\n        if (closed)\n            return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n        hideDialog(cm, dialog);\n    }\n    dialog.onclick = function (e) {\n        e.preventDefault();\n        close();\n    };\n    showDialog(cm, dialog);\n    if (duration)\n        doneTimer = setTimeout(close, duration);\n    return close;\n}\nfunction showDialog(cm, dialog) {\n    var oldDialog = cm.state.dialog;\n    cm.state.dialog = dialog;\n    if (dialog && oldDialog !== dialog) {\n        if (oldDialog && oldDialog.contains(document.activeElement))\n            cm.focus();\n        if (oldDialog && oldDialog.parentElement) {\n            oldDialog.parentElement.replaceChild(dialog, oldDialog);\n        }\n        else if (oldDialog) {\n            oldDialog.remove();\n        }\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction hideDialog(cm, dialog) {\n    if (cm.state.dialog == dialog) {\n        cm.state.dialog = null;\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction openDialog(me, template, callback, options) {\n    if (!options)\n        options = {};\n    closeNotification(me, undefined);\n    var dialog = dialogDiv(me, template, options.bottom);\n    var closed = false;\n    showDialog(me, dialog);\n    function close(newVal) {\n        if (typeof newVal == 'string') {\n            inp.value = newVal;\n        }\n        else {\n            if (closed)\n                return;\n            closed = true;\n            hideDialog(me, dialog);\n            if (!me.state.dialog)\n                me.focus();\n            if (options.onClose)\n                options.onClose(dialog);\n        }\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n        if (options.value) {\n            inp.value = options.value;\n            if (options.selectValueOnOpen !== false)\n                inp.select();\n        }\n        if (options.onInput)\n            CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n        if (options.onKeyUp)\n            CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                return;\n            }\n            if (e.keyCode == 13)\n                callback(inp.value);\n            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                inp.blur();\n                CodeMirror.e_stop(e);\n                close();\n            }\n        });\n        if (options.closeOnBlur !== false)\n            CodeMirror.on(inp, \"blur\", function () {\n                setTimeout(function () {\n                    if (document.activeElement === inp)\n                        return;\n                    close();\n                });\n            });\n        inp.focus();\n    }\n    return close;\n}\nvar matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\nfunction bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n        : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n            continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n            continue;\n        if (lineNo == where.line)\n            pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n            var ch = line.charAt(pos);\n            if (re.test(ch) /*&& (style === undefined ||\n                                (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n                var match = matching[ch];\n                if (match && (match.charAt(1) == \">\") == (dir > 0))\n                    stack.push(ch);\n                else if (!stack.length)\n                    return { pos: new Pos(lineNo, pos), ch: ch };\n                else\n                    stack.pop();\n            }\n        }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {\n}\nfunction findEnclosingTag(cm, pos) {\n    var _a, _b;\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    if (offset < state.doc.length) {\n        var text = state.sliceDoc(offset, offset + 1);\n        if (text == \"<\")\n            offset++;\n    }\n    var tree = ensureSyntaxTree(state, offset);\n    var node = (tree === null || tree === void 0 ? void 0 : tree.resolve(offset)) || null;\n    while (node) {\n        if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) == 'OpenTag'\n            && ((_b = node.lastChild) === null || _b === void 0 ? void 0 : _b.type.name) == 'CloseTag') {\n            return {\n                open: convertRange(state.doc, node.firstChild),\n                close: convertRange(state.doc, node.lastChild),\n            };\n        }\n        node = node.parent;\n    }\n}\nfunction convertRange(doc, cm6Range) {\n    return {\n        from: posFromIndex(doc, cm6Range.from),\n        to: posFromIndex(doc, cm6Range.to)\n    };\n}\nclass Marker {\n    constructor(cm, offset, assoc) {\n        this.cm = cm;\n        this.id = cm.$mid++;\n        this.offset = offset;\n        this.assoc = assoc;\n        cm.marks[this.id] = this;\n    }\n    ;\n    clear() { delete this.cm.marks[this.id]; }\n    ;\n    find() {\n        if (this.offset == null)\n            return null;\n        return this.cm.posFromIndex(this.offset);\n    }\n    ;\n    update(change) {\n        if (this.offset != null)\n            this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);\n    }\n}\n\nclass Piece {\n    constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n        this.left = left;\n        this.top = top;\n        this.height = height;\n        this.fontFamily = fontFamily;\n        this.fontSize = fontSize;\n        this.fontWeight = fontWeight;\n        this.color = color;\n        this.className = className;\n        this.letter = letter;\n        this.partial = partial;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        elt.style.height = this.height + \"px\";\n        elt.style.lineHeight = this.height + \"px\";\n        elt.style.fontFamily = this.fontFamily;\n        elt.style.fontSize = this.fontSize;\n        elt.style.fontWeight = this.fontWeight;\n        elt.style.color = this.partial ? \"transparent\" : this.color;\n        elt.className = this.className;\n        elt.textContent = this.letter;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.height == p.height &&\n            this.fontFamily == p.fontFamily && this.fontSize == p.fontSize &&\n            this.fontWeight == p.fontWeight && this.color == p.color &&\n            this.className == p.className &&\n            this.letter == p.letter;\n    }\n}\nclass BlockCursorPlugin {\n    constructor(view, cm) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.cm = cm;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = 1200 + \"ms\";\n    }\n    update(update) {\n        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n            this.view.requestMeasure(this.measureReq);\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        }\n    }\n    scheduleRedraw() {\n        this.view.requestMeasure(this.measureReq);\n    }\n    readPos() {\n        let { state } = this.view;\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            let piece = measureCursor(this.cm, this.view, r, prim);\n            if (piece)\n                cursors.push(piece);\n        }\n        return { cursors };\n    }\n    drawSel({ cursors }) {\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.cursorLayer.remove();\n    }\n}\nconst themeSpec = {\n    \".cm-vimMode .cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" },\n        caretColor: \"transparent !important\",\n    },\n    \".cm-fat-cursor\": {\n        position: \"absolute\",\n        background: \"#ff9696\",\n        border: \"none\",\n        whiteSpace: \"pre\",\n    },\n    \"&:not(.cm-focused) .cm-fat-cursor\": {\n        background: \"none\",\n        outline: \"solid 1px #ff9696\",\n        color: \"transparent !important\",\n    },\n};\nconst hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n    let head = cursor.head;\n    let fatCursor = false;\n    let hCoeff = 1;\n    let vim = cm.state.vim;\n    if (vim && (!vim.insertMode || cm.state.overwrite)) {\n        fatCursor = true;\n        if (vim.visualBlock && !primary)\n            return null;\n        if (cursor.anchor < cursor.head)\n            head--;\n        if (cm.state.overwrite)\n            hCoeff = 0.2;\n        else if (vim.status)\n            hCoeff = 0.5;\n    }\n    if (fatCursor) {\n        let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n        if (letter && (/[\\uDC00-\\uDFFF]/.test(letter) && head > 1)) {\n            // step back if cursor is on the second half of a surrogate pair\n            head--;\n            letter = view.state.sliceDoc(head, head + 1);\n        }\n        let pos = view.coordsAtPos(head, 1);\n        if (!pos)\n            return null;\n        let base = getBase(view);\n        let domAtPos = view.domAtPos(head);\n        let node = domAtPos ? domAtPos.node : view.contentDOM;\n        while (domAtPos && domAtPos.node instanceof HTMLElement) {\n            node = domAtPos.node;\n            domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };\n        }\n        if (!(node instanceof HTMLElement)) {\n            if (!node.parentNode)\n                return null;\n            node = node.parentNode;\n        }\n        let style = getComputedStyle(node);\n        let left = pos.left;\n        if (!letter || letter == \"\\n\" || letter == \"\\r\") {\n            letter = \"\\xa0\";\n        }\n        else if (letter == \"\\t\") {\n            letter = \"\\xa0\";\n            var nextPos = view.coordsAtPos(head + 1, -1);\n            if (nextPos) {\n                left = nextPos.left - (nextPos.left - pos.left) / parseInt(style.tabSize);\n            }\n        }\n        else if ((/[\\uD800-\\uDBFF]/.test(letter) && head < view.state.doc.length - 1)) {\n            // include the second half of a surrogate pair in cursor\n            letter += view.state.sliceDoc(head + 1, head + 2);\n        }\n        let h = (pos.bottom - pos.top);\n        return new Piece(left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n    }\n    else {\n        return null;\n    }\n}\n\nvar FIREFOX_LINUX = typeof navigator != \"undefined\"\n    && /*@__PURE__*//linux/i.test(navigator.platform)\n    && /*@__PURE__*// Gecko\\/\\d+/.exec(navigator.userAgent);\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n        display: \"none\",\n    },\n    \".cm-vim-panel\": {\n        padding: \"0px 10px\",\n        fontFamily: \"monospace\",\n        minHeight: \"1.3em\",\n    },\n    \".cm-vim-panel input\": {\n        border: \"none\",\n        outline: \"none\",\n        backgroundColor: \"inherit\",\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n});\nconst vimPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.status = \"\";\n        this.query = null;\n        this.decorations = Decoration.none;\n        this.waitForCopy = false;\n        this.lastKeydown = '';\n        this.useNextTextInput = false;\n        this.view = view;\n        const cm = (this.cm = new CodeMirror(view));\n        Vim.enterVimMode(this.cm);\n        this.view.cm = this.cm;\n        this.cm.state.vimPlugin = this;\n        this.blockCursor = new BlockCursorPlugin(view, cm);\n        this.updateClass();\n        this.cm.on(\"vim-command-done\", () => {\n            if (cm.state.vim)\n                cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateStatus();\n        });\n        this.cm.on(\"vim-mode-change\", (e) => {\n            cm.state.vim.mode = e.mode;\n            if (e.subMode) {\n                cm.state.vim.mode += \" block\";\n            }\n            cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateClass();\n            this.updateStatus();\n        });\n        this.cm.on(\"dialog\", () => {\n            if (this.cm.state.statusbar) {\n                this.updateStatus();\n            }\n            else {\n                view.dispatch({\n                    effects: showVimPanel.of(!!this.cm.state.dialog),\n                });\n            }\n        });\n        this.dom = document.createElement(\"span\");\n        this.dom.style.cssText = \"position: absolute; right: 10px; top: 1px\";\n        this.statusButton = document.createElement(\"span\");\n        this.statusButton.onclick = (e) => {\n            Vim.handleKey(this.cm, \"<Esc>\", \"user\");\n            this.cm.focus();\n        };\n        this.statusButton.style.cssText = \"cursor: pointer\";\n    }\n    update(update) {\n        var _a;\n        if ((update.viewportChanged || update.docChanged) && this.query) {\n            this.highlight(this.query);\n        }\n        if (update.docChanged) {\n            this.cm.onChange(update);\n        }\n        if (update.selectionSet) {\n            this.cm.onSelectionChange();\n        }\n        if (update.viewportChanged) ;\n        if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n            this.cm.onBeforeEndOperation();\n        }\n        if (update.transactions) {\n            for (let tr of update.transactions)\n                for (let effect of tr.effects) {\n                    if (effect.is(setSearchQuery)) {\n                        let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n                        if (!forVim) {\n                            this.highlight(null);\n                        }\n                        else {\n                            let query = effect.value.create();\n                            this.highlight(query);\n                        }\n                    }\n                }\n        }\n        this.blockCursor.update(update);\n    }\n    updateClass() {\n        const state = this.cm.state;\n        if (!state.vim || (state.vim.insertMode && !state.overwrite))\n            this.view.scrollDOM.classList.remove(\"cm-vimMode\");\n        else\n            this.view.scrollDOM.classList.add(\"cm-vimMode\");\n    }\n    updateStatus() {\n        let dom = this.cm.state.statusbar;\n        let vim = this.cm.state.vim;\n        if (!dom || !vim)\n            return;\n        let dialog = this.cm.state.dialog;\n        if (dialog) {\n            if (dialog.parentElement != dom) {\n                dom.textContent = \"\";\n                dom.appendChild(dialog);\n            }\n        }\n        else {\n            dom.textContent = \"\";\n            var status = (vim.mode || \"normal\").toUpperCase();\n            if (vim.insertModeReturn)\n                status += \"(C-O)\";\n            this.statusButton.textContent = `--${status}--`;\n            dom.appendChild(this.statusButton);\n        }\n        this.dom.textContent = vim.status;\n        dom.appendChild(this.dom);\n    }\n    destroy() {\n        Vim.leaveVimMode(this.cm);\n        this.updateClass();\n        this.blockCursor.destroy();\n        delete this.view.cm;\n    }\n    highlight(query) {\n        this.query = query;\n        if (!query)\n            return (this.decorations = Decoration.none);\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                builder.add(from, to, matchMark);\n            });\n        }\n        return (this.decorations = builder.finish());\n    }\n    handleKey(e, view) {\n        const key = CodeMirror.vimKey(e);\n        const cm = this.cm;\n        if (!key)\n            return;\n        let vim = cm.state.vim;\n        if (!vim)\n            return;\n        // clear search highlight\n        if (key == \"<Esc>\" &&\n            !vim.insertMode &&\n            !vim.visualMode &&\n            this.query /* && !cm.inMultiSelectMode*/) {\n            const searchState = vim.searchState_;\n            if (searchState) {\n                cm.removeOverlay(searchState.getOverlay());\n                searchState.setOverlay(null);\n            }\n        }\n        let isCopy = key === \"<C-c>\" && !CodeMirror.isMac;\n        if (isCopy && cm.somethingSelected()) {\n            this.waitForCopy = true;\n            return true;\n        }\n        vim.status = (vim.status || \"\") + key;\n        let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n        vim = cm.state.vim; // the object can change if there is an exception in handleKey\n        // insert mode\n        if (!result && vim.insertMode && cm.state.overwrite) {\n            if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n                result = true;\n                cm.overWriteSelection(e.key);\n            }\n            else if (e.key == \"Backspace\") {\n                result = true;\n                CodeMirror.commands.cursorCharLeft(cm);\n            }\n        }\n        if (result) {\n            CodeMirror.signal(this.cm, 'vim-keypress', key);\n            e.preventDefault();\n            e.stopPropagation();\n            this.blockCursor.scheduleRedraw();\n        }\n        this.updateStatus();\n        return !!result;\n    }\n}, {\n    eventHandlers: {\n        copy: function (e, view) {\n            if (!this.waitForCopy)\n                return;\n            this.waitForCopy = false;\n            Promise.resolve().then(() => {\n                var cm = this.cm;\n                var vim = cm.state.vim;\n                if (!vim)\n                    return;\n                if (vim.insertMode) {\n                    cm.setSelection(cm.getCursor(), cm.getCursor());\n                }\n                else {\n                    cm.operation(() => {\n                        if (cm.curOp)\n                            cm.curOp.isVimOp = true;\n                        Vim.handleKey(cm, '<Esc>', 'user');\n                    });\n                }\n            });\n        },\n        compositionstart: function (e, view) {\n            this.useNextTextInput = true;\n        },\n        keypress: function (e, view) {\n            if (this.lastKeydown == \"Dead\")\n                this.handleKey(e, view);\n        },\n        keydown: function (e, view) {\n            this.lastKeydown = e.key;\n            if (this.lastKeydown == \"Unidentified\"\n                || this.lastKeydown == \"Process\"\n                || this.lastKeydown == \"Dead\") {\n                this.useNextTextInput = true;\n            }\n            else {\n                this.useNextTextInput = false;\n                this.handleKey(e, view);\n            }\n        },\n    },\n    provide: () => {\n        return [\n            EditorView.inputHandler.of((view, from, to, text) => {\n                var _a, _b;\n                var cm = getCM(view);\n                if (!cm)\n                    return false;\n                var vim = (_a = cm.state) === null || _a === void 0 ? void 0 : _a.vim;\n                var vimPlugin = cm.state.vimPlugin;\n                if (vim && !vim.insertMode && !((_b = cm.curOp) === null || _b === void 0 ? void 0 : _b.isVimOp)) {\n                    if (text === \"\\0\\0\") {\n                        return true;\n                    }\n                    if (text.length == 1 && vimPlugin.useNextTextInput) {\n                        vimPlugin.handleKey({\n                            key: text,\n                            preventDefault: () => { },\n                            stopPropagation: () => { }\n                        });\n                    }\n                    forceEndComposition(view);\n                    return true;\n                }\n                return false;\n            })\n        ];\n    },\n    decorations: (v) => v.decorations,\n});\n/**\n * removes contenteditable element and adds it back to end\n * IME composition in normal mode\n * this method works on all browsers except for Firefox on Linux\n * where we need to reset textContent of editor\n * (which doesn't work on other browsers)\n */\nfunction forceEndComposition(view) {\n    var parent = view.scrollDOM.parentElement;\n    if (!parent)\n        return;\n    if (FIREFOX_LINUX) {\n        view.contentDOM.textContent = \"\\0\\0\";\n        view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n        return;\n    }\n    var sibling = view.scrollDOM.nextSibling;\n    var selection = window.getSelection();\n    var savedSelection = selection && {\n        anchorNode: selection.anchorNode,\n        anchorOffset: selection.anchorOffset,\n        focusNode: selection.focusNode,\n        focusOffset: selection.focusOffset\n    };\n    view.scrollDOM.remove();\n    parent.insertBefore(view.scrollDOM, sibling);\n    try {\n        if (savedSelection && selection) {\n            selection.setPosition(savedSelection.anchorNode, savedSelection.anchorOffset);\n            if (savedSelection.focusNode) {\n                selection.extend(savedSelection.focusNode, savedSelection.focusOffset);\n            }\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n    view.focus();\n    view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" });\nconst showVimPanel = /*@__PURE__*/StateEffect.define();\nconst vimPanelState = /*@__PURE__*/StateField.define({\n    create: () => false,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(showVimPanel))\n                value = e.value;\n        return value;\n    },\n    provide: (f) => {\n        return showPanel.from(f, (on) => (on ? createVimPanel : null));\n    },\n});\nfunction createVimPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    if (cm.state.dialog) {\n        dom.appendChild(cm.state.dialog);\n    }\n    return { top: false, dom };\n}\nfunction statusPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    cm.state.statusbar = dom;\n    cm.state.vimPlugin.updateStatus();\n    return { dom };\n}\nfunction vim(options = {}) {\n    return [\n        vimStyle,\n        vimPlugin,\n        hideNativeSelection,\n        options.status ? showPanel.of(statusPanel) : vimPanelState,\n    ];\n}\nfunction getCM(view) {\n    return view.cm || null;\n}\n\nexport { CodeMirror, Vim, getCM, vim };\n"],
  "mappings": "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",
  "names": ["CodeMirror", "Pos", "vim", "vimKey", "keys", "query", "macroModeState", "e", "i", "dir", "cm", "options", "commandMatch", "noremap", "numberRegex", "repeat", "on", "from", "to", "vimPlugin"]
}
